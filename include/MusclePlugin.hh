#ifndef _GAZEBO_MUSCLE_HH_
#define _GAZEBO_MUSCLE_HH_

#include "gazebo/common/Plugin.hh"
#include "gazebo/util/system.hh"
#include <sstream>
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <ignition/math/Vector3.hh>
#include <ignition/math/Pose3.hh>
#include <gazebo/common/common.hh>
#include <boost/bind.hpp>
#include <math.h>
#include <map>
#include <stdio.h>
#include <algorithm> 
#include <boost/numeric/odeint.hpp>



namespace gazebo
{
  
	using namespace std;
	using namespace boost::numeric::odeint; 

	const int linkNumber = 3; //later read this number from some table or .txt files

  struct Motor
    {
      float current;
      float torqueConst;
      float resistance;
      float inductance;
      float voltage;
      float BEMFConst; // back electromagnetic force constant
      float inertiaMoment;
    };

    struct Gear
    {
      float inertiaMoment;
      float ratio;
      float efficiency; // gear efficciency
      float appEfficiency; // approximated efficiency 
    };

    struct Spindle
    {
      float angVel; // angular velocity of the spindle
      float radius;
    };

    struct SEE
    {
	  float stiffness;
	  float length;
	  float lengthRest;
    };

    struct tendonType {
	  math::Vector3 MidPoint[linkNumber-1];
	  math::Vector3 Vector[linkNumber-1];//might need it to calculate length
	  math::Vector3 Orientation[linkNumber-1];
	  double Pitch[linkNumber-1];
	  double Roll[linkNumber-1];
	} ;

	
    class ITendon
 	{
	    ////////////////////////////////////////
	    /// \brief Calculate the dot product between two vectors
	    /// \param[in] _v1 vector 1 coordinates
	    /// \param[in] _v2 vector 2 coordinates
	    /// \return Dot product
	    private: float DotProduct(const math::Vector3 &_v1, const math::Vector3 &_v2);

	    ////////////////////////////////////////
	    /// \brief Calculate the angle between two vectors
	    /// \param[in] _v1 vector 1 coordinates
	    /// \param[in] _v2 vector 2 coordinates
	    /// \return Angle between two vectors in radians
	    private: float Angle(const math::Vector3 &_v1, const math::Vector3 &_v2);

	    ////////////////////////////////////////
	    /// \brief Calculate torque for an electric motor model.
	    /// \param[in] _current Input electric current
	    /// \param[in] _torqueConstant Motor's torque constant
	    /// \param[in] _spindleRadius Radius of the spindle that coils up the tendon
	    /// \return Calculated force according to the model
	    public: float ElectricMotorModel(const float _current,  const float _torqueConstant, 
	                                const float _spindleRadius);

	    ////////////////////////////////////////
	    /// \brief Calculate elastic force of the series elastic element
	    /// \param[in] _length0 Resting length of the SEE
	    /// \param[in] _length Current length of the SEE 
	    /// \param[in] _stiffness Deafault values for stiffness of the SEE
	    /// \return Elastic force in N
	    public: float ElasticElementModel(const float _length0, const float _length, 
	                                float _stiffness,  const float _speed, 
	                                const float _spindleRadius, const double _time);

	    ////////////////////////////////////////
	    /// \brief Calculate forces generated by the motor and SEE
	    /// \param[in] _elasticForce
	    /// \param[in] _motorForce  
	    /// \param[in] position and orientation of the tendon
	    /// \return Motor force in N
	    public: math::Vector3 CalculateForce(float _elasticForce, float _motorForce, 
                              const math::Vector3 &_tendonOrien);



    	public: static void GetTendonInfo(math::Vector3 _viaPointPose[], tendonType *tendon_p);

    }; 


  class IActuator
  {
	  	// state vector for differential model
		public: typedef std::vector< double > state_type;
		// private: std::vector< double > x(2);
	    
	    // stepper for integration
	    public: boost::numeric::odeint::runge_kutta4< state_type > stepper;

	    ////////////////////////////////////////
	    /// \brief Approximates gear's velocity
	    /// according to the direction of the rotation of the gear, i.e. 
	    /// eta or 1/eta
	    /// \return Approximated value for gear efficiency
	    public: static float EfficiencyApproximation();
	    // private: void DiffModel(const state_type &x , state_type &dxdt , const double /* t */);


	    ////////////////////////////////////////
	    /// \brief Describes the differential model 
	    /// for the simulations of dynamics 
	    /// of a DC motor, a spindle, and a gear box
	    public: static void DiffModel( const state_type &x , state_type &dxdt , const double /* t */ );
  };


	class MusclePlugin : public ModelPlugin
	{
  
	    public: MusclePlugin();

	    public: void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf);
	    public: void Init();

	    private: void OnUpdate();

	    private: event::ConnectionPtr connection;
	    private: common::Time prevUpdateTime;
	    private: physics::ModelPtr model;
	    private: std::vector<physics::LinkPtr> links;

  };
}

#endif