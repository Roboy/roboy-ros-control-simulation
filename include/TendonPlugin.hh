#ifndef _GAZEBO_TENDON_PLUGIN_HH_
#define _GAZEBO_TENDON_PLUGIN_HH_

#include <gazebo/common/Plugin.hh>
#include <gazebo/util/system.hh>
#include <sstream>
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/math/Vector3.hh>
#include <gazebo/common/common.hh>
#include <boost/bind.hpp>
#include <math.h>
#include <map>
#include <stdio.h>

///Example SDF:
  ///    <plugin name="tendon_plugin" filename="libtendon_plugin.so">
  ///         <motor>
  ///             <electric_current>0.1</electric_current>
  ///             <torque_constant>1</torque_constant>
  ///         </motor>
  ///         <spindle>
  ///             <radius>0.005</radius>
  ///         </spindle>
  ///         <SEE>
  ///             <stiffness>1.0 2.0 3.0 4.0</stiffness>
  ///             <length>0.5</length>
  ///         </SEE>
  ///     </plugin>
  ///  </model>
  ///
  /// \brief This plugin calculates the forces from the electric motor and the elastics element,
  /// that are connected to the tendon. 
  /// The plugin also applies this force to the points of fixation and insertion of the tendon.
 
namespace gazebo
{
  
  class MotorProperties
  {
    public: float eCurrent;
    public: float torqueConst;
    public: float spindleRadius;
    public: float speed;
  };

  class SEEProperties
  {
    public: float stiffness[4];
    public: float length;
    public: float lengthRest;
  };

   class TendonPlugin : public ModelPlugin
  {

    public: TendonPlugin();

    public: void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf);
    public: void Init();

    private: void OnUpdate();

    ////////////////////////////////////////
    /// \brief Calculate the dot product between two vectors
    /// \param[in] _v1 vector 1 coordinates
    /// \param[in] _v2 vector 2 coordinates
    /// \return Dot product
    private: float DotProduct(const math::Vector3 &_v1, const math::Vector3 &_v2);

    ////////////////////////////////////////
    /// \brief Calculate the angle between two vectors
    /// \param[in] _v1 vector 1 coordinates
    /// \param[in] _v2 vector 2 coordinates
    /// \return Angle between two vectors in radians
    private: float Angle(const math::Vector3 &_v1, const math::Vector3 &_v2);

    ////////////////////////////////////////
    /// \brief Calculate torque for an electric motor model.
    /// \param[in] _current Input electric current
    /// \param[in] _torqueConstant Motor's torque constant
    /// \param[in] _spindleRadius Radius of the spindle that coils up the tendon
    /// \return Calculated force according to the model
    private: float ElectricMotorModel(const float _current,  const float _torqueConstant, 
                                const float _spindleRadius);

    ////////////////////////////////////////
    /// \brief Calculate elastic force of the series elastic element
    /// \param[in] _length0 Resting length of the SEE
    /// \param[in] _length Current length of the SEE 
    /// \param[in] _stiffness Deafault values for stiffness of the SEE
    /// \return Elastic force in N
    private: float ElasticElementModel(const float _length0, const float _length, 
                                float _stiffness[],  const float _speed, const float _spindleRadius);

    ////////////////////////////////////////
    /// \brief Calculate forces generated by the motor and SEE
    /// \param[in] _elasticForce
    /// \param[in] _motorForce  
    /// \param[in] _instertionP Position of the insertion point of the tendon 
    /// \param[in] _fixationP Position of the fixation point of the tendon 
    /// \param[in] _jointP Position of the corresponding joint 
    /// \return Motor force in N
    private: math::Vector3 CalculateForce(float _elasticForce, float _motorForce, 
                              const math::Vector3 &_instertionP,
                              const math::Vector3 &_fixationP);

    private: event::ConnectionPtr connection;

    private: physics::ModelPtr model;

    private: std::vector<physics::LinkPtr> links;

   /* /// \brief Dictionary for series elastic element properties
    private: std::map <std::string,boost::variant<float,std::vector<float>> SEE;

    /// \brief Dictionary for motor properties
    private: std::map <std::string,float> motor;*/
  };  
}

#endif
